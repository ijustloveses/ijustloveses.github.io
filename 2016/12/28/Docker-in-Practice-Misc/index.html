<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="笔记,Docker,Network,安全,监控,DevOps," />





  <link rel="alternate" href="/atom.xml" title="泡茶说" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Some miscellenious topics on 《Manning Docker in Practice》">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker in Practice - Misc">
<meta property="og:url" content="http://ijustloveses.github.io/2016/12/28/Docker-in-Practice-Misc/index.html">
<meta property="og:site_name" content="泡茶说">
<meta property="og:description" content="Some miscellenious topics on 《Manning Docker in Practice》">
<meta property="og:updated_time" content="2016-12-28T03:09:47.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Docker in Practice - Misc">
<meta name="twitter:description" content="Some miscellenious topics on 《Manning Docker in Practice》">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <title> Docker in Practice - Misc | 泡茶说 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">泡茶说</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Docker in Practice - Misc
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-28T03:05:16+00:00" content="2016-12-28">
              2016-12-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/28/Docker-in-Practice-Misc/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/28/Docker-in-Practice-Misc/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
              &nbsp; | &nbsp;
              <span class="page-pv"><i class="fa fa-file-o"></i>
              <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
              </span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Some miscellenious topics on 《Manning Docker in Practice》</p>
<a id="more"></a>
<h1 id="Docker-Security"><a href="#Docker-Security" class="headerlink" title="Docker Security"></a>Docker Security</h1><h3 id="限制-capabilities"><a href="#限制-capabilities" class="headerlink" title="限制 capabilities"></a>限制 capabilities</h3><p>即使你使用非 root 的用户来启动 Docker 容器，你在容器中仍然具有 root 权限。而 Docker 还可以 mount 宿主机的目录，这样就有漏洞了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -v /sbin:/sbin busybox rm -rf /sbin    # 不要运行这个语句，你会删除 /sbin 目录下的文件，这很危险</span><br><span class="line">$ docker run -v /etc/shadow:/etc/shadow busybox cat /etc/shadow    # 这个命令会展示用户密码文件内容</span><br></pre></td></tr></table></figure></p>
<p>即使两个用户都是 root 用户，他们也会有不同的权限，Linux 通过 capabilities 提供 fine-grained 权限控制。</p>
<p>当容器启动时，如果不加控制，有些 capabilities 是默认打开的，有些再是默认关闭的，比如：</p>
<blockquote>
<p>CHOWN 开启<br>DAC_OVERRIDE 开启<br>FOWNER 开启<br>SYS_CHROOT 开启<br>……..<br>IPC_LOCK 关闭<br>MAC_ADMIN 关闭<br>NET_ADMIN 关闭<br>……..</p>
</blockquote>
<p>一个极端的方案是，在容器启动时，通过 –cap-drop 选项关闭全部 capabilities，然后运行容器，如果不能正常运行，则开启导致错误的那些 capabilities，直到容器正常运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -ti --cap-drop=CHOWN --cap-drop=DAC_OVERRIDE \</span><br><span class="line">--cap-drop=FSETID --cap-drop=FOWNER --cap-drop=KILL --cap-drop=MKNOD \</span><br><span class="line">--cap-drop=NET_RAW --cap-drop=SETGID --cap-drop=SETUID \</span><br><span class="line">--cap-drop=SETFCAP --cap-drop=SETPCAP --cap-drop=NET_BIND_SERVICE \</span><br><span class="line">--cap-drop=SYS_CHROOT --cap-drop=AUDIT_WRITE debian /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>最后，还是要说明一下，capabilities 是控制 root 用户如何使用其他用户资源的权限，而 root 用户对其自身的资源仍有完全的控制权限</p>
<h3 id="通过-HTTP-auth-来访问-Docker-容器"><a href="#通过-HTTP-auth-来访问-Docker-容器" class="headerlink" title="通过 HTTP auth 来访问 Docker 容器"></a>通过 HTTP auth 来访问 Docker 容器</h3><p>我们通过 -H 命令，使用 http 方式来启动 docker，代理后台的 unix domain socket；然后加入 http authentication，只允许有权限的用户访问 http 接口。所对应的代码在<a href="https://github.com/docker-in-practice/docker-authenticate" target="_blank" rel="external">这里</a></p>
<p>dockerinpractice/docker-authenticate 镜像的 Dockerfile 如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM debian</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y nginx apache2-utils</span><br><span class="line">RUN htpasswd -c /etc/nginx/.htpasswd username               # 创建用户 username 的密码文件</span><br><span class="line">RUN htpasswd -b /etc/nginx/.htpasswd username password      # 设置密码为 password</span><br><span class="line">RUN sed -i &apos;s/user .*;/user root;/&apos; /etc/nginx/nginx.conf   # nginx 文件中的 user 指定为 root，因为需要 root 权限来访问 docker unix socket</span><br><span class="line">ADD etc/nginx/sites-enabled/docker /etc/nginx/sites-enabled/docker     # 把 etc/nginx/sites-enabled/docker 加到 nginx site 中，后面介绍</span><br><span class="line">CMD service nginx start &amp;&amp; sleep infinity                   # 启动 nginx</span><br></pre></td></tr></table></figure></p>
<p>nginx 站点 etc/nginx/sites-enabled/docker 如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">upstream docker &#123;</span><br><span class="line">  server unix:/var/run/docker.sock;      # 定义 docker unix socket 为 upstream，名为 docker</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 2375 default_server;      # 监听 2357</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://docker;      # 把请求转到上面定义的 docker socket</span><br><span class="line">    auth_basic_user_file /etc/nginx/.htpasswd;    # 请求的用户密码文件</span><br><span class="line">    auth_basic &quot;Access restricted&quot;;               # 严格执行密码访问</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好了，现在可以启动容器了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name docker-authenticate -p 2375:2375 \     # 监听 2375 端口</span><br><span class="line">-v /var/run:/var/run dockerinpractice/docker-authenticate     # mount /var/run/docker.sock 所在的目录，以获取 docker daemon 和 socket 的访问权</span><br></pre></td></tr></table></figure></p>
<p>对宿主机 2375 端口的请求，通过端口映射发送给容器 2375 端口的 http 代理，进而转发给容器的 unix:/var/run/docker.sock，通过 mount，这个请求其实就是发送给宿主机的 docker unix socket；经过这一番曲折，实现了 http authentication</p>
<p>现在尝试对这个 web service 访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://username:password@localhost:2375/info</span><br><span class="line">&#123;&quot;Containers&quot;:115,&quot;Debug&quot;:0,</span><br><span class="line"> &quot;DockerRootDir&quot;:&quot;/var/lib/docker&quot;,&quot;Driver&quot;:&quot;aufs&quot;,</span><br><span class="line"> &quot;DriverStatus&quot;:[[&quot;Root Dir&quot;,&quot;/var/lib/docker/aufs&quot;],</span><br><span class="line"> ..........</span><br></pre></td></tr></table></figure></p>
<p>我们看到此时对 docker 的访问，需要使用 restful api 的方式；那么能直接使用 docker 命令么？比如下面这样？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker -H tcp://username:password@localhost:2375 ps</span><br></pre></td></tr></table></figure></p>
<p>目前 docker 命令本身还不支持 user/password authentication，原著笔者创建了一个镜像来解决这个问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name docker-authenticate-client -p 127.0.0.1:12375:12375 \</span><br><span class="line">dockerinpractice/docker-authenticate-client 192.168.1.74:2375 username:password</span><br><span class="line"></span><br><span class="line">$ docker -H localhost:12375 ps    # 问题解决！</span><br></pre></td></tr></table></figure></p>
<p>思考一下这个的实现方式：用户通过 -H 的方式访问 12375 端口，通过端口映射把请求传给容器的 12375 端口；我们知道，Docker 内部其实就是使用 restful api 来通讯的，那么容器 12375 端口的 web service 只需要把 docker 的 restful api 加上 username:password 再转发给前面实现的 http 认证的 web service 即可</p>
<h3 id="使用密钥确保-Docker-API-的安全"><a href="#使用密钥确保-Docker-API-的安全" class="headerlink" title="使用密钥确保 Docker API 的安全"></a>使用密钥确保 Docker API 的安全</h3><p>类似 ssh，Docker 也可以通过密钥来保证连接和 API 调用的安全</p>
<p>具体的密钥生成命令就省略了，简单的说，服务器端生成以下密钥文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ca.key.pem / server-key.pem / ca.pem / server-cert.pem / cert.pem / key.pem</span><br></pre></td></tr></table></figure></p>
<p>然后 docker daemon 的配置文件中加入如下选项，并重启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=&quot;$DOCKER_OPTS --tlsverify&quot;</span><br><span class="line">DOCKER_OPTS=&quot;$DOCKER_OPTS --tlscacert=/etc/docker/ca.pem&quot;</span><br><span class="line">DOCKER_OPTS=&quot;$DOCKER_OPTS --tlscert=/etc/docker/server-cert.pem&quot;</span><br><span class="line">DOCKER_OPTS=&quot;$DOCKER_OPTS --tlskey=/etc/docker/server-key.pem&quot;</span><br><span class="line">DOCKER_OPTS=&quot;$DOCKER_OPTS -H tcp://0.0.0.0:2376&quot;</span><br><span class="line">DOCKER_OPTS=&quot;$DOCKER_OPTS -H unix:///var/run/docker.sock&quot;</span><br></pre></td></tr></table></figure></p>
<p>把其中的 ca.pem / cert.pem / key.pem 发布给客户端</p>
<p>然后 Docker 的客户端就可以使用这些密钥安全调用 Docker Server 了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker --tlsverify --tlscacert=/etc/docker/ca.pem \</span><br><span class="line">--tlscert=/etc/docker/cert.pem --tlskey=/etc/docker/key.pem \     # 指定密钥文件</span><br><span class="line">-H myserver.localdomain:2376 info       # 通过 -H 选项调用 docker 命令</span><br></pre></td></tr></table></figure></p>
<h3 id="使用-MAC-tool-比如-Selinux"><a href="#使用-MAC-tool-比如-Selinux" class="headerlink" title="使用 MAC tool 比如 Selinux"></a>使用 MAC tool 比如 Selinux</h3><p>除了前面介绍的 capabilities 外，还可以用 MAC(mandatory access control) 工具如 Selinux 来做 fine-grained 访问限制</p>
<p>Selinux 是 NSA 开发的工具用来保护其系统，使用于 Red Hat 相关的 linux 系统，而 Debian-based 系统对应工具为 AppArmor</p>
<p>首先需要安装 Selinux，可以通过 sestatus 命令查看系统是否已经安装过 Selinux；然后要 yum 安装 selinuxpolicy-devel 包</p>
<p>运行 sestatus 看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># sestatus</span><br><span class="line">SELinux status: enabled    # 已开启</span><br><span class="line">SELinuxfs mount: /sys/fs/selinux</span><br><span class="line">SELinux root directory: /etc/selinux</span><br><span class="line">Loaded policy name: targeted</span><br><span class="line">Current mode: permissive     # permissive 模式，指 selinux 会记录所有违规行为，但是不会约束它们；很适合测试环境</span><br><span class="line">Mode from config file: permissive      # 如果当前不是 permissive 模式，可以调用 setenforce Permissive 命令设置</span><br><span class="line">Policy MLS status: enabled</span><br><span class="line">Policy deny_unknown status: allowed</span><br><span class="line">Max kernel policy version: 28</span><br></pre></td></tr></table></figure></p>
<p>另外，还要确保 docker daemon 设置了 –selinux-enabled 选项，可以通过下面命令确认<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -fe|grep &apos;docker -d.*--selinux-enabled&apos;</span><br></pre></td></tr></table></figure></p>
<p>OK，准备工作完毕。以 root 身份创建一个策略文件目录，进入目录创建策略文件，名为 docker_apache.te，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">policy_module(docker_apache,1.0)    # 策略名为 docker_apache，版本 1.0</span><br><span class="line">virt_sandbox_domain_template(docker_apache)   # 此模版创建 docker_apache_t 类型，运行为 docker 容器，初始权限很少</span><br><span class="line">allow docker_apache_t self: capability &#123; chown dac_override kill setgid setuid net_bind_service sys_chroot sys_nice sys_tty_config &#125; ;         # 这里添加新的 capability 权限</span><br><span class="line">allow docker_apache_t self:tcp_socket create_stream_socket_perms;   # 以下添加 Apache 监听的相关网络权限</span><br><span class="line">allow docker_apache_t self:udp_socket create_socket_perms;</span><br><span class="line">corenet_tcp_bind_all_nodes(docker_apache_t)</span><br><span class="line">corenet_tcp_bind_http_port(docker_apache_t)</span><br><span class="line">corenet_udp_bind_all_nodes(docker_apache_t)</span><br><span class="line">corenet_udp_bind_http_port(docker_apache_t)</span><br><span class="line">sysnet_dns_name_resolve(docker_apache_t)</span><br><span class="line">#permissive docker_apache_t    # 可选项，指定 permissive 模式。可在不改变主机模式的情况下，为策略重载主机模式</span><br></pre></td></tr></table></figure></p>
<p>编译策略文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ make -f /usr/share/selinux/devel/Makefile docker_apache.te     # 这会得到一个 docker_apache.pp 二进制策略文件</span><br><span class="line">Compiling targeted docker_apache module</span><br><span class="line">.........</span><br><span class="line">Creating targeted docker_apache.pp policy package</span><br><span class="line">rm tmp/docker_apache.mod tmp/docker_apache.mod.fc</span><br><span class="line"></span><br><span class="line">$ semodule -i docker_apache.pp      # 安装编译好的策略文件</span><br></pre></td></tr></table></figure></p>
<p>试试看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ setenforce Enforcing          # 设置为 enforcing，对违反策略的行为，不仅报错，而且会阻止其运行</span><br><span class="line">$ docker run -ti --name selinuxdock --security-opt \     # 指定了容器运行时应用 docker_apache_t 策略 </span><br><span class="line">  label:type:docker_apache_t httpd                       # 容器的运行将会被阻止，因为违规</span><br><span class="line">.........</span><br><span class="line">Status: Downloaded newer image for httpd:latest</span><br><span class="line">permission denied</span><br><span class="line">$ docker rm -f selinuxdock      # 清理未正常启动的容器</span><br></pre></td></tr></table></figure></p>
<p>研究为何出错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ setenforce Permissive       # 设置会 permissive 模式</span><br><span class="line">$ docker run -d --name selinuxdock --security-opt label:type:docker_apache_t httpd    # 再次运行，应该会记录错误</span><br><span class="line"></span><br><span class="line">$ grep -w denied /var/log/audit/audit.log         # 查看错误日志</span><br><span class="line">..........</span><br></pre></td></tr></table></figure></p>
<p>上面会报出很多错误的信息和描述。如果你并不熟悉 selinux，那么研究这些错误并针对性的更新原有策略是很复杂的事情，那么有一个工具帮助你根据错误日志来生成新的策略以修正这些错误，这个工具是 audit2allow<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /root/selinux_policy_httpd_auto        # 创建新的策略目录，并进入目录</span><br><span class="line">cd /root/selinux_policy_httpd_auto</span><br><span class="line">audit2allow -a -w                               # 通过 -M 选项指明你给新策略所起的名字</span><br><span class="line">audit2allow -a -M newmodname create policy</span><br><span class="line">semodule -i newmodname.pp                       # 生成新的策略文件，并安装之</span><br></pre></td></tr></table></figure></p>
<h1 id="日志-Logging-amp-Monitering"><a href="#日志-Logging-amp-Monitering" class="headerlink" title="日志 Logging &amp; Monitering"></a>日志 Logging &amp; Monitering</h1><h3 id="把容器的日志记录在宿主机的-syslog-里"><a href="#把容器的日志记录在宿主机的-syslog-里" class="headerlink" title="把容器的日志记录在宿主机的 syslog 里"></a>把容器的日志记录在宿主机的 syslog 里</h3><p>Linux 系统通常都运行着 syslog daemon，应用程序把日志发送到 syslogd 的 touchpoint (/dev/log)，由 syslogd 来可靠的记录和保存日志 (/var/log/syslog)。Docker 容器默认并不安装 syslogd，这不妨碍我们在每个容器中安装和启动 syslogd，不过这样每个容器的日志都保存在各自的文件系统中，我们希望有一个集中的 central location 来保存所有的日志，便于收集和管理</p>
<p>central syslog daemon 容器的 Dockerfile 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:14.04</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install rsyslog    # syslogd 服务容器安装 rsyslog 软件包，r stands for reliable</span><br><span class="line">VOLUME /dev               # 创建 /dev volume，是 syslogd 的 touchpoint</span><br><span class="line">VOLUME /var/log           # 创建 /var/log volume，mount 宿主机目录，用于集中保存 syslog 日志文件，</span><br><span class="line">CMD rsyslogd -n           # 启动 syslod daemon</span><br></pre></td></tr></table></figure></p>
<p>创建和启动容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t syslogger .</span><br><span class="line">docker run --name syslogger -d -v /tmp/syslogdev:/dev syslogger     # touch point 映射到宿主 /tmp/syslogdev/log</span><br></pre></td></tr></table></figure></p>
<p>这样，在宿主机上，可以看到 /tmp/syslogdev 目录已经 mount 好了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -1 /tmp/syslogdev/</span><br><span class="line">fd</span><br><span class="line">full</span><br><span class="line">..........</span><br><span class="line">zero</span><br></pre></td></tr></table></figure></p>
<p>现在可以启动应用容器来调用 syslog 记录日志了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for d in &#123;1..100&#125;</span><br><span class="line">do</span><br><span class="line">    docker run -d -v /tmp/syslogdev/log:/dev/log ubuntu logger hi_$d      # mount /tmp/syslogdev/log 到 /dev/log</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>注意，ubuntu 的 logger 程序会把消息记录到 syslogd 的 touch point /dev/log 文件，进而通过 mount 记录到宿主的 /tmp/syslogdev/log，进而再通过 mount 记录到 central syslogd service 容器的 /dev/log，然后会被 rsyslog 记录到容器的 /var/log/syslog 中去，达成集中收集 syslog 日志的目标<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -ti syslogger tail -f /var/log/syslog</span><br><span class="line">May 25 11:55:15 f4fb5d829699 logger: hi_1</span><br><span class="line">May 25 11:55:15 f4fb5d829699 logger: hi_2</span><br><span class="line">[...]</span><br><span class="line">May 25 11:57:39 f4fb5d829699 logger: hi_99     # 看到不同应用容器的系统日志都集中记录到 central syslog 服务容器</span><br></pre></td></tr></table></figure></p>
<p>几点说明如下：</p>
<ul>
<li>本节介绍了通过宿主机的同一个目录分别 mount 在 syslog 服务容器和所有应用容器，达到系统日志集中到一起的目标</li>
<li>/var/log volumne 也可以 mount 到宿主机中去，这样应用容器的日志就可以在宿主机上去管理了</li>
<li>使用本技巧的应用容器只能使用 logger 等记录 syslog 的程序，而不能用于集中管理普通的程序日志</li>
<li>最后，本技巧仅限于集中管理单宿主机上的应用容器，无法应用于跨宿主机容器的情况</li>
<li>这里我忽然有个想法，是不是通过宿主的同一个目录分别去 mount 各容器的 /var/log 目录会更简单，且不限于 syslog 呢？想象中，这个方法可能要解决不同容器中的同名文件的访问冲突问题</li>
</ul>
<h3 id="把-Docker-logs-日志记录由宿主的应用程序接管"><a href="#把-Docker-logs-日志记录由宿主的应用程序接管" class="headerlink" title="把 Docker logs 日志记录由宿主的应用程序接管"></a>把 Docker logs 日志记录由宿主的应用程序接管</h3><p>Docker 提供 docker logs 命令来捕获容器启动程序的日志，而且还提供 –log-driver 选项来指定宿主机的特定应用程序管理 docker logs 日志，包括 syslog / journald / json-file。syslog 在上一节中介绍过了，它使用 /dev/log 作为 touch point 来接收日志并输出到 /var/log/syslog；journald 是一个收集和管理结构化索引日志的系统服务，通过 journalctl 命令来查询日志</p>
<p>把日志输出到 syslog<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --log-driver=syslog ubuntu echo &apos;outputting to syslog&apos;    # 容器 start 程序为 echo</span><br><span class="line"></span><br><span class="line">$ grep &apos;outputting to syslog&apos; /var/log/syslog        # 查看</span><br></pre></td></tr></table></figure></p>
<p>把日志输出到 journald<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --log-driver=journald ubuntu echo &apos;outputting to journald&apos;</span><br><span class="line"></span><br><span class="line">$ journalctl | grep &apos;outputting to journald&apos;         # 查看</span><br></pre></td></tr></table></figure></p>
<p>可以设置在 Docker 的默认配置 (/etc/default/docker or /etc/sysconfig/docker) 的 DOCKER_OPTS 中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=&quot;--dns 8.8.8.8 --dns 8.8.4.4 --log-driver syslog&quot;</span><br></pre></td></tr></table></figure></p>
<p>这样就不用每次使用 –log-driver 选项来启动容器了</p>
<p>注意，这个方法只对容器启动时执行的 start 程序的日志有效，其他容器内应用的日志不会记录到 docker logs 中，自然无效</p>
<p>另外，还可以使用容器实现一个 ELK logging 框架，好处是对跨宿主机的容器有效</p>
<h3 id="使用-cAdvisor-监控容器"><a href="#使用-cAdvisor-监控容器" class="headerlink" title="使用 cAdvisor 监控容器"></a>使用 cAdvisor 监控容器</h3><p>你想要监控大量容器的资源使用率、性能？Google 开源的 <a href="https://github.com/google/cadvisor" target="_blank" rel="external">cAdvisor</a> 是个不错的选择</p>
<p>启动 cAdvisor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --volume /:/rootfs:ro \       # 只读 mount 系统 root 目录，以收集文件系统信息</span><br><span class="line">--volume /var/run:/var/run:rw \            # 读写 mount /var/run 目录</span><br><span class="line">--volume /sys:/sys:ro \                    # 只读 mount 系统 sys 目录，以收集 kernel 和 devices 信息</span><br><span class="line">--volume /var/lib/docker/:/var/lib/docker:ro \    # 只读 mount docker 目录，收集 docker 信息</span><br><span class="line">-p 8080:8080 -d --name cadvisor \          # 8080 web interface</span><br><span class="line">--restart on-failure:10 google/cadvisor    # 失败自动重启，共计 10 次</span><br></pre></td></tr></table></figure></p>
<p>登录 <a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a> 可以查看宿主、容器的 cpu、内存等信息；数据保存在系统中，也可以配置保存在 InfluxDB</p>
<h1 id="Resource-Control"><a href="#Resource-Control" class="headerlink" title="Resource Control"></a>Resource Control</h1><p>Docker 使用 cgroups 来管理容器资源使用，默认的策略是简单的平均分配算法，然而有时这样是不够的</p>
<h3 id="限制容器运行在特定的-cpu-cores-上"><a href="#限制容器运行在特定的-cpu-cores-上" class="headerlink" title="限制容器运行在特定的 cpu cores 上"></a>限制容器运行在特定的 cpu cores 上</h3><p>默认的，Docker 可以执行在宿主的任何 cpu cores 上，容器如果是单进程的，那么只会占用一个 core，而如果是多线程的，那么可以使用所有的 cores；而 Docker 还可以通过 –cpuset-cpus 硬性指定容器运行在哪个 cores 上</p>
<p>运行两个容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu:14.04 sh -c &apos;cat /dev/zero &gt;/dev/null&apos;</span><br></pre></td></tr></table></figure></p>
<p>你会发现两个 cpu cores 占用率 100%</p>
<p>如果这样运行两个容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --cpuset-cpus=0 ubuntu:14.04 sh -c &apos;cat /dev/zero &gt;/dev/null&apos;</span><br></pre></td></tr></table></figure></p>
<p>你会发现第一个 core 占用率 100%，因为两个容器全部运行在第一个 core 上</p>
<p>–cpuset-cpus 选项允许指定多个 cores，格式如 (0,1,2)，或者 (0-2)，或者 (0-1,3)</p>
<h3 id="给重要的容器更多的-cpu-资源"><a href="#给重要的容器更多的-cpu-资源" class="headerlink" title="给重要的容器更多的 cpu 资源"></a>给重要的容器更多的 cpu 资源</h3><p>在 docker run 启动容器时，可以使用 -c/–cpu-shares 选项来分配容器对 cpu 资源的优先级；如果不指定，那么默认为 1024。要注意，当只有一个容器时，那么它一定 100% 占有 cpu 资源，不管 -c/–cpu-shares 选项的值是多少。-c/–cpu-shares 选项只有当多个容器竞争 cpu 资源时，才发生作用。特别的，假如两个容器都是单线程应用，运行在 2-cores 宿主上，那么无论它俩的 -c/–cpu-shares 值是多少，都只会各占 1 个 core</p>
<p>假如现在有 A,B,C 3 个容器，那么</p>
<ul>
<li>都不设置 -c/–cpu-shares，那么每个容器 1/3 </li>
<li>A &amp; B 512, C 1024，那么 A &amp; B 各占 1/4，C 占 1/2</li>
<li>A 10, B 100, C 1000，那么 A 占不到 1%，B 占不到 10%，C 占不到 90%</li>
</ul>
<h3 id="限制容器内存的使用"><a href="#限制容器内存的使用" class="headerlink" title="限制容器内存的使用"></a>限制容器内存的使用</h3><p>当容器运行时，可以分配宿主机上全部的内存；同时，我们还可以通过 -m/–memory 选项限制容器能分配的内存</p>
<p>注意，对于 Ubuntu 系统，这个 capability 并不是默认 enable 的，可以调用 docker info 查看是否有 “No swap limit support” 警告，如果有那么就需要做一些设置，让 kernel 知道在系统启动时 enable memory-limiting capability。具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 修改 /etc/default/grub 文件，加入</span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;cgroup_enable=memory swapaccount=1&quot;</span><br><span class="line"></span><br><span class="line">$ sudo update-grub</span><br></pre></td></tr></table></figure></p>
<p>然后重启系统即可</p>
<p>接下来可以做一些测试了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it -m 4m ubuntu:14.04 bash        # 限制内存分配最大 4m</span><br><span class="line">root@cffc126297e2:/# python3 -c &apos;open(&quot;/dev/zero&quot;).read(10*1024*1024)&apos;    # 尝试通过 python 分配 10m</span><br><span class="line">Killed                                          # 脚本运行失败</span><br><span class="line">root@e9f13cacd42f:/# A=$(dd if=/dev/zero bs=1M count=10 | base64)         # 尝试通过命令行分配 10m</span><br><span class="line">$                                               # Bash 被 killed，容器退出，回到宿主机的 Bash</span><br><span class="line">$ echo $?</span><br><span class="line">137                                             # 返回错误码 137</span><br></pre></td></tr></table></figure></p>
<p>接下来的测试使用 jess/stress 镜像中的 stress 工具，来测试系统的极限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -m 100m jess/stress --vm 1 --vm-bytes 150M --vm-hang 0</span><br></pre></td></tr></table></figure></p>
<p>上面的命令指定容器内存分配 limit 为 100m，容器启动时会使用 stress 分配 150m，会失败么？答案是不会</p>
<p>可以使用下面的命令来验证 stress 确实分配了 150m 内存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top &lt;container_id&gt; -eo pid,size,args</span><br></pre></td></tr></table></figure></p>
<p>那么，为什么没有失败呢？原来 Docker 会 double-reserve 内存，其中一半为实际物理内存，一半为 swap；故此，-m 100m 选项其实指定的 limit 为 200m 内存，故此没有失败。那么如果让 stress 分配 250m 肯定会失败吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -m 100m jess/stress --vm 1 --vm-bytes 250M --vm-hang 0</span><br></pre></td></tr></table></figure></p>
<p>上面这条命令确实立刻就 terminate 了</p>
<p>double-reservation 策略是默认的设置，不过我们可以通过 –memory 和 –memory-swap 的配合设置来调整。比如两个选项设置为相同的值，你就完全禁掉了 swap 内存，或者说 swap 内存 limit 为 0</p>
<h3 id="访问宿主机的资源"><a href="#访问宿主机的资源" class="headerlink" title="访问宿主机的资源"></a>访问宿主机的资源</h3><p>容器使用 kernel 的 namespace 来做到资源的隔离，然而我们还是有很多方式来 bypass namespace，直接访问宿主机的资源</p>
<h5 id="v-volumn-mounting"><a href="#v-volumn-mounting" class="headerlink" title="-v volumn mounting"></a>-v volumn mounting</h5><p>volumes 是最常见的访问宿主机资源的方式，主要的好处有两点</p>
<ul>
<li>方便的共享宿主机的文件，而不需要把文件加到镜像的 layers 中，减少镜像的体积</li>
<li>访问宿主机的文件系统，比访问容器内部的文件系统要快，性能更好</li>
</ul>
<h5 id="–net-host-直接共享宿主机网络"><a href="#–net-host-直接共享宿主机网络" class="headerlink" title="–net=host 直接共享宿主机网络"></a>–net=host 直接共享宿主机网络</h5><p>是完全的使用宿主机的网络，比如通过 netstat 命令可以看到宿主机上的网络应用和端口信息，而不会生成 veth 接口和 bridge 虚拟局域网 ip。主要的好处如下：</p>
<ul>
<li>更容易的 connect 容器，直接当做宿主机来访问就行，代价是失去了端口映射功能 (比如两个容器都想监听 80 端口，就不能都使用 –net=host 了，否则就要端口冲突了)</li>
<li>网络连接的速度和性能更好<ul>
<li>–net=host 方式，直接使用宿主机网络，那么网络数据包就直接走 TCP/IP 到达 NIC (network interface card)</li>
<li>容器常规方式下，数据包则要经过 TCP/IP -&gt; Veth pair -&gt; Bridge -&gt; NAT 最终到达 NIC</li>
</ul>
</li>
</ul>
<h5 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h5><ul>
<li>–pid=host 用于共享宿主机的 pid 信息</li>
<li>–ipc=host 用于共享宿主机的共享内存、ipc 等资源</li>
<li>–uts=host 用于共享宿主机的 hostname, NIS domain 等资源</li>
</ul>
<h3 id="Device-Mapper-storage-driver-和默认容器磁盘空间"><a href="#Device-Mapper-storage-driver-和默认容器磁盘空间" class="headerlink" title="Device Mapper storage driver 和默认容器磁盘空间"></a>Device Mapper storage driver 和默认容器磁盘空间</h3><p>Docker 自带一些 storage drivers 的支持，比如 Centos &amp; Red Hat 默认的 devicemapper，Ubuntu 默认的 AUFS 等；相比起来，devicemapper bug 少一些，而且在一些方面上更加灵活</p>
<p>Devicemapper 默认的行为是分配一个文件，把它视为 “device” 来读写，比如我们上面提到过的 syslog 使用 /dev/log 文件来写入。这个设备文件是有 capability limit 的，不能自动增加文件尺寸</p>
<p>比如下面的 Dockerfile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:14.04</span><br><span class="line">RUN truncate --size 11G /root/file</span><br></pre></td></tr></table></figure></p>
<p>在 build 镜像时会出错，11G 太大了，无论你的宿主机有多大的磁盘空间也都会失败，因为 devicemapper 对容器的限制是 10G</p>
<p>通过 –storage-opt dm.basesize=xxx 来修改，我们还可以把它放到 DOCKER_OPTIONS 中，避免每次都带上这个选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTIONS=&quot;-s devicemapper --storage-opt dm.basesize=20G&quot;</span><br></pre></td></tr></table></figure></p>
<h1 id="调试容器"><a href="#调试容器" class="headerlink" title="调试容器"></a>调试容器</h1><h3 id="使用-nsenter-调试容器网络"><a href="#使用-nsenter-调试容器网络" class="headerlink" title="使用 nsenter 调试容器网络"></a>使用 nsenter 调试容器网络</h3><p>之前介绍过使用 socat 作为 proxy，代理对其他容器服务的请求，此时可以通过 socat 来调试和诊断对容器的网络连接；然而如果仅为了调试来 setup socat proxy 还是稍嫌复杂了，使用 nsenter 可以更加便捷的完成调试任务。</p>
<h5 id="容器化安装"><a href="#容器化安装" class="headerlink" title="容器化安装"></a>容器化安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -v /usr/local/bin:/target jpetazzo/nsenter</span><br></pre></td></tr></table></figure>
<p>此时，nsenter 会被安装在宿主的 /usr/local/bin 目录，可以在宿主机上直接被调用，就像直接安装在宿主机上一样</p>
<h5 id="通过宿主机的-bash-访问容器"><a href="#通过宿主机的-bash-访问容器" class="headerlink" title="通过宿主机的 bash 访问容器"></a>通过宿主机的 bash 访问容器</h5><p>我们知道 BusyBox 镜像是不带 bash 的，下面通过 nsenter 来达成使用宿主机 bash 进入容器的目标<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -ti busybox /bin/bash     # 这个会失败， busybox 不带 /bin/bash</span><br><span class="line">FATA[0000] Error response from daemon: Cannot start container</span><br><span class="line">$ CID=$(docker run -d busybox sleep 9999)    # 启动 busybox 并进入 sleep，把容器 id 保存到 CID 中</span><br><span class="line">$ PID=$(docker inspect --format &#123;&#123;.State.Pid&#125;&#125; $CID)    # 获取 busybox 容器的 PID</span><br><span class="line">$ sudo nsenter --target $PID \       # 在宿主机运行 nsenter，通过 --target 指定欲进入的容器 PID</span><br><span class="line">--uts --ipc --net /bin/bash          # 其他选项指定 capability 以及进入容器后要启动的程序，也即宿主机的 /bin/bash</span><br><span class="line">root@781c1fed2b18:~#                 # 看到进入容器了，而且启动了 /bin/bash</span><br></pre></td></tr></table></figure></p>
<h5 id="使用宿主的-tcpdump-来调试网络应用"><a href="#使用宿主的-tcpdump-来调试网络应用" class="headerlink" title="使用宿主的 tcpdump 来调试网络应用"></a>使用宿主的 tcpdump 来调试网络应用</h5><p>要使用 tcpdump，在启动 nsenter 的时候需要指定 –net 选项，以允许在宿主机上看到容器的网络，进而才能通过 tcpdump 调试</p>
<p>这里假定我们还在上一节启动的 busybox 容器中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@781c1fed2b18:/# tcpdump -XXs 0 -w /tmp/google.tcpdump &amp;      # 容器中使用宿主的 bash，后台启动宿主的 tcpdump</span><br><span class="line"></span><br><span class="line">root@781c1fed2b18:/# wget google.com      # 然后调用一个 wget 命令，让 tcpdump 来 dump 网络连接信息</span><br><span class="line">Resolving google.com (google.com)... 216.58.208.46, 2a00:1450:4009:80d::200e</span><br><span class="line">............</span><br><span class="line">http://www.google.co.uk/?gfe_rd=cr&amp;ei=tLzEVcCXN7Lj8wepgarQAQ</span><br><span class="line">Resolving www.google.co.uk (www.google.co.uk)... 216.58.208.67, 2a00:1450:4009:80a::2003</span><br><span class="line">............</span><br><span class="line">Saving to: ‘index.html’</span><br><span class="line">2015-08-07 15:12:05 (2.18 MB/s) - ‘index.html’ saved [18720]</span><br><span class="line">............</span><br></pre></td></tr></table></figure></p>
<h5 id="找出宿主机中目标容器所对应的-veth-interface-设备"><a href="#找出宿主机中目标容器所对应的-veth-interface-设备" class="headerlink" title="找出宿主机中目标容器所对应的 veth interface 设备"></a>找出宿主机中目标容器所对应的 veth interface 设备</h5><p>有时我们需要很快的 down 掉目标容器的网络，一般的做法是使用一些网络工具来模拟网络 breakage，非常麻烦。我们看看用 nsenter 怎么完成这个任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name offlinetest ubuntu:14.04.2 sleep infinity        # 重新启动一个目标容器</span><br><span class="line">fad037a77a2fc337b7b12bc484babb2145774fde7718d1b5b53fb7e9dc0ad7b3</span><br><span class="line"></span><br><span class="line">$ docker exec offlinetest ping -q -c1 8.8.8.8</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms     # 验证容器内部 ping 是 ok 的</span><br><span class="line"></span><br><span class="line">$ docker exec offlinetest ifconfig eth0 down      # 验证我们不能直接在宿主机上 down 掉容器的网络</span><br><span class="line">SIOCSIFFLAGS: Operation not permitted</span><br><span class="line"></span><br><span class="line">$ PID=$(docker inspect --format &#123;&#123;.State.Pid&#125;&#125; offlinetest)     # 找到容器 PID 准备 nsenter 进入容器</span><br><span class="line">$ nsenter --target $PID --net ethtool -S eth0      # 进入容器，且指定 --net 选项，并启动宿主的 ethtool 工具</span><br><span class="line">NIC statistics:</span><br><span class="line">peer_ifindex: 53         # 容器的 eth0 是 veth pair 的一端，另一端在宿主机上</span><br><span class="line"></span><br><span class="line">$ ip addr | grep &apos;^53&apos;   # 宿主机上查找 53 interface</span><br><span class="line">53: veth2e7d114: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP</span><br><span class="line"></span><br><span class="line">$ sudo ifconfig veth2e7d114 down      # 上面看到 53 接口对应的 veth pair 就是 veth2e7d114 ，down 掉它！</span><br><span class="line"></span><br><span class="line">$ docker exec offlinetest ping -q -c1 8.8.8.8</span><br><span class="line">1 packets transmitted, 0 received, 100% packet loss, time 0ms      # 看到容器断网了！</span><br></pre></td></tr></table></figure></p>
<p>综上 3 个例子，nsenter 的作用集中体现在可以进入容器内，同时使用或者说保留宿主机的诊断工具，非常方便，因为容器不需要做任何设置和修改</p>
<h3 id="使用-tcpflow-调试容器网络"><a href="#使用-tcpflow-调试容器网络" class="headerlink" title="使用 tcpflow 调试容器网络"></a>使用 tcpflow 调试容器网络</h3><p>前面的技巧中，我们可以通过 nsenter 使用宿主机的 tcpdump 来研究容器的网络包信息，然而 tcpdump 属于比较底层的调试工具，上手难度高，而且如果要调试更上层的应用程序，会比较复杂和麻烦；可以考虑使用 tcpflow</p>
<p>容器安装和启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ IMG=dockerinpractice/tcpflow</span><br><span class="line">$ docker pull $IMG</span><br><span class="line">$ alias tcpflow=&quot;docker run --rm --net host $IMG&quot;        # 注意到 --net=host 选项，共享宿主机的网络</span><br></pre></td></tr></table></figure></p>
<p>有两种方法来调试容器的网络包</p>
<ul>
<li>监控 docker0 interface，此时宿主机和容器全部网络包都会被监控，需要使用 packet-filtering expression 来过滤</li>
<li>类似上一节的方法，找到并监控对应容器的 veth pair interface，这样监控到的都是容器的网络包</li>
</ul>
<p>第一种就很好用，看下例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name tcpflowtest alpine:3.2 sleep 30d               # 启动一个 alpine 容器做测试</span><br><span class="line">$ docker inspect -f &apos;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&apos; tcpflowtest    # 容器的内部局域网 ip</span><br><span class="line">172.17.0.1</span><br><span class="line">$ tcpflow -c -J -i docker0 &apos;host 172.17.0.1 and port 80&apos;              # 监控 docker0 接口，并过滤内网 ip 和端口</span><br><span class="line">tcpflow: listening on docker0</span><br></pre></td></tr></table></figure></p>
<p>看到，使用起来非常方便，而且同样不需要修改和配置目标容器</p>
<h3 id="容器应用失败的调试"><a href="#容器应用失败的调试" class="headerlink" title="容器应用失败的调试"></a>容器应用失败的调试</h3><p>当容器中有应用程序运行失败，又找不出原因时，可以考虑使用 strace 工具来跟踪系统调用，然后和正常运行的应用程序做比较，可能会帮助找到问题所在</p>
<p>比如在 ubuntu:12.04 的容器中，常常会遇到下面的错误，而 ubuntu:14.04 就没问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@centos vagrant]# docker run -ti ubuntu:12.04</span><br><span class="line">root@afade8b94d32:/# useradd -m -d /home/dockerinpractice dockerinpractice       # useradd 会失败</span><br><span class="line">root@afade8b94d32:/# echo $?               # 返回非 0 值</span><br><span class="line">12</span><br></pre></td></tr></table></figure></p>
<p>使用 strace 工具来追踪<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># strace -f \          # -f 选项跟踪进程以及进程的派生进程</span><br><span class="line">useradd -m -d /home/dockerinpractice dockerinpractice     # 后面跟着需要跟踪的进程</span><br><span class="line"></span><br><span class="line">execve(&quot;/usr/sbin/useradd&quot;, [&quot;useradd&quot;, &quot;-m&quot;, &quot;-d&quot;, ... &quot;dockerinpractice&quot;], ... = 0       # 以下是输出，execve 表示执行参数中的命令，最后的 0 表示这条命令的返回值</span><br><span class="line">[...]</span><br><span class="line">open(&quot;/proc/self/task/39/attr/current&quot;, O_RDONLY) = 9      # 到这个命令时，打开文件，返回的 9 是文件的 handle</span><br><span class="line">read(9, &quot;system_u:system_r:svirt_lxc_net_&quot;...,4095) = 46   # 读 handle 9 对应的文件</span><br><span class="line">close(9) = 0                                               # 关闭文件</span><br><span class="line">[...]</span><br><span class="line">open(&quot;/etc/selinux/config&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)    # 运行到这里出错了，未找到文件</span><br><span class="line">open(&quot;/etc/selinux/targeted/contexts/files/ file_contexts.subs_dist&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/etc/selinux/targeted/contexts/files/</span><br><span class="line">file_contexts.subs&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/etc/selinux/targeted/contexts/files/ file_contexts&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">[...]</span><br><span class="line">exit_group(12)         # 这个就是整个应用最终的返回值 12</span><br></pre></td></tr></table></figure></p>
<p>那么我们找到了问题，是因为应用要访问 selinux 的文件，然而并没有这个文件</p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/笔记/" rel="tag">#笔记</a>
          
            <a href="/tags/Docker/" rel="tag">#Docker</a>
          
            <a href="/tags/Network/" rel="tag">#Network</a>
          
            <a href="/tags/安全/" rel="tag">#安全</a>
          
            <a href="/tags/监控/" rel="tag">#监控</a>
          
            <a href="/tags/DevOps/" rel="tag">#DevOps</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/11/30/Docker-in-Practice-Etcd/" rel="next" title="Docker in Practice - Etcd">
                <i class="fa fa-chevron-left"></i> Docker in Practice - Etcd
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/28/Docker-in-Practice-Advanced/" rel="prev" title="Docker in Practice - Advanced">
                Docker in Practice - Advanced <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/12/28/Docker-in-Practice-Misc/"
           data-title="Docker in Practice - Misc" data-url="http://ijustloveses.github.io/2016/12/28/Docker-in-Practice-Misc/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="泡茶" />
          <p class="site-author-name" itemprop="name">泡茶</p>
          <p class="site-description motion-element" itemprop="description">专注并发和机器学习</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">34</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ijustloveses" target="_blank" title="Github" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker-Security"><span class="nav-number">1.</span> <span class="nav-text">Docker Security</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#限制-capabilities"><span class="nav-number">1.0.1.</span> <span class="nav-text">限制 capabilities</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过-HTTP-auth-来访问-Docker-容器"><span class="nav-number">1.0.2.</span> <span class="nav-text">通过 HTTP auth 来访问 Docker 容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用密钥确保-Docker-API-的安全"><span class="nav-number">1.0.3.</span> <span class="nav-text">使用密钥确保 Docker API 的安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-MAC-tool-比如-Selinux"><span class="nav-number">1.0.4.</span> <span class="nav-text">使用 MAC tool 比如 Selinux</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#日志-Logging-amp-Monitering"><span class="nav-number">2.</span> <span class="nav-text">日志 Logging & Monitering</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#把容器的日志记录在宿主机的-syslog-里"><span class="nav-number">2.0.1.</span> <span class="nav-text">把容器的日志记录在宿主机的 syslog 里</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#把-Docker-logs-日志记录由宿主的应用程序接管"><span class="nav-number">2.0.2.</span> <span class="nav-text">把 Docker logs 日志记录由宿主的应用程序接管</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-cAdvisor-监控容器"><span class="nav-number">2.0.3.</span> <span class="nav-text">使用 cAdvisor 监控容器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Resource-Control"><span class="nav-number">3.</span> <span class="nav-text">Resource Control</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#限制容器运行在特定的-cpu-cores-上"><span class="nav-number">3.0.1.</span> <span class="nav-text">限制容器运行在特定的 cpu cores 上</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#给重要的容器更多的-cpu-资源"><span class="nav-number">3.0.2.</span> <span class="nav-text">给重要的容器更多的 cpu 资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#限制容器内存的使用"><span class="nav-number">3.0.3.</span> <span class="nav-text">限制容器内存的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问宿主机的资源"><span class="nav-number">3.0.4.</span> <span class="nav-text">访问宿主机的资源</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#v-volumn-mounting"><span class="nav-number">3.0.4.0.1.</span> <span class="nav-text">-v volumn mounting</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#–net-host-直接共享宿主机网络"><span class="nav-number">3.0.4.0.2.</span> <span class="nav-text">–net=host 直接共享宿主机网络</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#其他方式"><span class="nav-number">3.0.4.0.3.</span> <span class="nav-text">其他方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Device-Mapper-storage-driver-和默认容器磁盘空间"><span class="nav-number">3.0.5.</span> <span class="nav-text">Device Mapper storage driver 和默认容器磁盘空间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#调试容器"><span class="nav-number">4.</span> <span class="nav-text">调试容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-nsenter-调试容器网络"><span class="nav-number">4.0.1.</span> <span class="nav-text">使用 nsenter 调试容器网络</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#容器化安装"><span class="nav-number">4.0.1.0.1.</span> <span class="nav-text">容器化安装</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通过宿主机的-bash-访问容器"><span class="nav-number">4.0.1.0.2.</span> <span class="nav-text">通过宿主机的 bash 访问容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用宿主的-tcpdump-来调试网络应用"><span class="nav-number">4.0.1.0.3.</span> <span class="nav-text">使用宿主的 tcpdump 来调试网络应用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#找出宿主机中目标容器所对应的-veth-interface-设备"><span class="nav-number">4.0.1.0.4.</span> <span class="nav-text">找出宿主机中目标容器所对应的 veth interface 设备</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-tcpflow-调试容器网络"><span class="nav-number">4.0.2.</span> <span class="nav-text">使用 tcpflow 调试容器网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器应用失败的调试"><span class="nav-number">4.0.3.</span> <span class="nav-text">容器应用失败的调试</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">泡茶</span>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"paochashuo"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  






  
  
  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
