<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="并发,多线程,7日7并发模型,笔记," />





  <link rel="alternate" href="/atom.xml" title="泡茶说" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Notes on 7 Concurrent Models in 7 Weeks - Part 1. Thread and Lock">
<meta property="og:type" content="article">
<meta property="og:title" content="7周7并发模型 P1 - Thread and Lock">
<meta property="og:url" content="http://ijustloveses.github.io/2016/06/28/7concurrent-models-in-7weeks-part1/index.html">
<meta property="og:site_name" content="泡茶说">
<meta property="og:description" content="Notes on 7 Concurrent Models in 7 Weeks - Part 1. Thread and Lock">
<meta property="og:updated_time" content="2016-06-29T06:17:47.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="7周7并发模型 P1 - Thread and Lock">
<meta name="twitter:description" content="Notes on 7 Concurrent Models in 7 Weeks - Part 1. Thread and Lock">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <title> 7周7并发模型 P1 - Thread and Lock | 泡茶说 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">泡茶说</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                7周7并发模型 P1 - Thread and Lock
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-28T18:27:25+00:00" content="2016-06-29">
              2016-06-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/并发/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/28/7concurrent-models-in-7weeks-part1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/28/7concurrent-models-in-7weeks-part1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
              &nbsp; | &nbsp;
              <span class="page-pv"><i class="fa fa-file-o"></i>
              <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
              </span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Notes on 7 Concurrent Models in 7 Weeks - Part 1. Thread and Lock</p>
<a id="more"></a>
<p><strong>How to create a thread</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread myThread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"Hello from new thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    myThread.start();</span><br><span class="line">    Thread.yield();</span><br><span class="line">    System.out.println(<span class="string">"Hello from main thread"</span>);</span><br><span class="line">    myThread.join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Why Thread.yield();<br>yield() is a hint to the scheduler that the current thread is willing to yield the current use of a processor.<br>Without this call, the startup overhead of the new thread would mean that the main thread would almost certainly print first.</p>
<p><strong>Intrinsic Lock</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123; ++count; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Intrinsic lock comes built into every Java object.</p>
<p><em>synchronized</em> claims that the Counter object’ lock when it is called and released when it returns.</p>
<p>The code has some flaws which will be revealed later.</p>
<p><strong>Mysterious Memory</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puzzle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">boolean</span> answerReady = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        answer = <span class="number">42</span>;</span><br><span class="line">        answerReady = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">static</span> Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (answerReady)</span><br><span class="line">          System.out.println(<span class="string">"The meaning of life is: "</span> + answer);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          System.out.println(<span class="string">"I don't know the answer"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    t1.start(); t2.start();</span><br><span class="line">    t1.join(); t2.join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>The output could be: “The meaning of life is: 0”, how is it possible? Because line 6 &amp; 7 could be swipped due to</p>
<ol>
<li>Compiler statically optimization by reordering</li>
<li>JVM dynamically optimization</li>
<li>Hardware is allowded to optimize performance</li>
</ol>
<p>And it goes further than just reordering, sometimes it could even change the logic … </p>
<p>Take above example, the line 7 could even be skipped and answerReady might not be true forever …</p>
<p><strong>Memory Visibility</strong></p>
<p>The java memory model defines when changes to memory made by one thread become visible to another thread.</p>
<p>The bottom line is that there are no guarantees unless both the <em>reading and writing</em> threads use synchronization.</p>
<p>The flaw in the code of <em>Intrinsic Lock</em> section<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123; ++count; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Yep, getCount() needs to be synchronized as well, or a thread calling getCount() may see a stale (not fresh) value.</p>
<p><strong>Dead Lock when there are multiple locks</strong></p>
<p>Based on previous sections, it is the only safe way in a multithread world to make every method synchronized, but:</p>
<ol>
<li>it is dreadfully inefficient.</li>
<li>as soon as you have more than one lock, the opportunity is created for the threads to become deadlocked.</li>
</ol>
<p><em>Dining Philosophers - dead locked version</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Chopstick left, right;</span><br><span class="line">  <span class="keyword">private</span> Random random;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(Chopstick left, Chopstick right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.left = left; <span class="keyword">this</span>.right = right;</span><br><span class="line">    random = <span class="keyword">new</span> Random();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        Thread.sleep(random.nextInt(<span class="number">1000</span>));     <span class="comment">// Think for a while</span></span><br><span class="line">        <span class="keyword">synchronized</span>(left) &#123;                    <span class="comment">// Grab left chopstick</span></span><br><span class="line">          <span class="keyword">synchronized</span>(right) &#123;                 <span class="comment">// Grab right chopstick</span></span><br><span class="line">            Thread.sleep(random.nextInt(<span class="number">1000</span>)); <span class="comment">// Eat for a while</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>The alternative way of claiming an object’s intrinsic lock: synchronized(object)  </p>
<p>— claiming an object’s intrinsic lock from outer (by other objects)</p>
<p>The main role of the thread is a philosopher which holds two Chopsticks, and the philosopher will lock left one and the right one in a row.<br>If 5 philosophers going simultaneousely, then they will lock their left Chopsticks at the same time, and try to lock their right ones,<br>which have been already locked by the philosophers on their right side —- BOOM, dead lock !!</p>
<p>Dead lock is a danger whenever a thread tries to hold more than one lock.</p>
<p>How to fix it ??</p>
<ol>
<li>Order the chopstick by some rules.</li>
<li>Instead of lock chopstick from left to right, lock them in ascending or descending order.<br>Done !</li>
</ol>
<p><strong>The peril of Alien Method</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downloader</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;ProgressListener&gt; listeners;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Downloader</span><span class="params">(URL url, String outputFilename)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    listeners = <span class="keyword">new</span> ArrayList&lt;ProgressListener&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(ProgressListener listener)</span> </span>&#123;</span><br><span class="line">    listeners.add(listener);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeListener</span><span class="params">(ProgressListener listener)</span> </span>&#123;</span><br><span class="line">    listeners.remove(listener);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">updateProgress</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ProgressListener listener: listeners)</span><br><span class="line">      listener.onProgress(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>((n = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        out.write(buffer, <span class="number">0</span>, n);</span><br><span class="line">        total += n;</span><br><span class="line">        updateProgress(total);</span><br><span class="line">      &#125;</span><br><span class="line">      out.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3 public method are all synchronized, looks good !</p>
<p>The problem is that the updateProgress() calls an alien method - a method it knows nothing about.</p>
<p>listener.onProgress() could do anything, including acquiring another lock, which make this a multiple locks case, and dead lock could happen.</p>
<p>How to fixed it? Defensive copy!<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateProgress</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  ArrayList&lt;ProgressListener&gt; listenersCopy;</span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    listenersCopy = (ArrayList&lt;ProgressListener&gt;)listeners.clone();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (ProgressListener listener: listenersCopy)</span><br><span class="line">    listener.onProgress(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>This fix kills several birds with one stone:</p>
<ol>
<li>Avoid calling an alien method with a lock held.</li>
<li>Minimizes the period during which we hold the lock.</li>
<li>A listener could now call removeListener() within its onProgress() method without modifying the copy of listener that is mid-iteration.</li>
</ol>
<p><em>Drawback of Intrinsic Lock</em></p>
<ol>
<li>No way to interrupt a thread that’s blocked as a result of trying to acquire an intrinsic lock.</li>
<li>No way to time out while trying to acquire an intrinsic lock.</li>
<li>Only one way to acquire an intrinsic lock: synchronized block, so lock acquisition and release have to take place in the same method and strictly nested.</li>
</ol>
<p><strong>ReentrantLock to rescue</strong></p>
<p>Pattern:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  &lt;&lt;use shared resources&gt;&gt;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Reentrant Lock is interruptable</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interruptible</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock l1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock l2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          l1.lockInterruptibly();</span><br><span class="line">          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          l2.lockInterruptibly();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; System.out.println(<span class="string">"t1 interrupted"</span>); &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          l2.lockInterruptibly();</span><br><span class="line">          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          l1.lockInterruptibly();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; System.out.println(<span class="string">"t2 interrupted"</span>); &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t1.start(); t2.start();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    t1.interrupt(); t2.interrupt();</span><br><span class="line">    t1.join(); t2.join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>It supposed to be deadlocked, but with the help of {$lock.}lockInterruptibly() and {$thead.}interrupt(), dead lock could be interrupted.</p>
<p><strong>Reentrant lock supports timeout</strong></p>
<p>Another solution fo Dining Philosopher problem – Timeout if the philosophers could not acquire some of their chopstick.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ReentrantLock leftChopstick, rightChopstick;</span><br><span class="line">  ......</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(ReentrantLock leftChopstick, ReentrantLock rightChopstick)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.leftChopstick = leftChopstick; <span class="keyword">this</span>.rightChopstick = rightChopstick;</span><br><span class="line">    random = <span class="keyword">new</span> Random();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        Thread.sleep(random.nextInt(<span class="number">1000</span>)); <span class="comment">// Think for a while</span></span><br><span class="line">        leftChopstick.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (rightChopstick.tryLock(<span class="number">1000</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">            <span class="comment">// Got the right chopstick</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              Thread.sleep(random.nextInt(<span class="number">1000</span>)); <span class="comment">// Eat for a while</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; rightChopstick.unlock(); &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Didn't get the right chopstick - give up and go back to thinking</span></span><br><span class="line">            System.out.println(<span class="string">"Philosopher "</span> + <span class="keyword">this</span> + <span class="string">" timed out"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; leftChopstick.unlock(); &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>rightChopstick.tryLock(1000, TimeUnit.MILLISECONDS) supports timeout.</p>
<p>Although the tryLock() solution avoids infinite deadlock, that doesn’t mean it is a good solution.</p>
<ol>
<li>It doesn’t avoid deadlock, but simple provides a way to recover when deadlock happens.</li>
<li>It is susceptible to <em>livelock</em> phenomenon – if all the threads timeout at the same time, it is possible for them to immediately deadlock again.<br>Although the deadlock doesn’t last forever, no progress is made either. (solve livelock by using different timeout.)</li>
</ol>
<p><strong>Hand-over-Hand Locking for a linked-list</strong></p>
<p>To insert a node, instead of lock the whole linked-list, we only lock the two nodes on either side of the point we’re going to insert.</p>
<p>It is impossible to do it with Intrinsic Lock.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSortedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node prev;</span><br><span class="line">    Node next;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line">    Node(<span class="keyword">int</span> value, Node prev, Node next) &#123;</span><br><span class="line">      <span class="keyword">this</span>.value = value; <span class="keyword">this</span>.prev = prev; <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Node head;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Node tail;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSortedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = <span class="keyword">new</span> Node(); tail = <span class="keyword">new</span> Node();</span><br><span class="line">    head.next = tail; tail.prev = head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    Node current = head;</span><br><span class="line">    current.lock.lock();</span><br><span class="line">    Node next = current.next;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        next.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (next == tail || next.value &lt; value) &#123;</span><br><span class="line">            Node node = <span class="keyword">new</span> Node(value, current, next);</span><br><span class="line">            next.prev = node;</span><br><span class="line">            current.next = node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; current.lock.unlock(); &#125;</span><br><span class="line">        current = next;</span><br><span class="line">        next = current.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; next.lock.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node current = tail;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (current.prev != head) &#123;</span><br><span class="line">      ReentrantLock lock = current.lock;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        current = current.prev;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Each node has a Reentrant Lock.</p>
<p>insert() iterates linked-list from head to tail, whereas size() iterate from tail to head.</p>
<p>So, doesn’t these different iterate directions violate the “Always acquire multiple locks in a fixed global order” rule? </p>
<p>(Remember that this rule fixed Dining Philosophers problem)</p>
<p>No, it doesn’t violate the rule, coz the size() method never holds more than a single lock at a time</p>
<p><strong>Condition Variable</strong></p>
<p>Concurrent programming often involves waiting for something to happen, and this type of situation is what condition variables are designed to address.</p>
<p>Pattern:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock()</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (!&lt;&lt;condition is <span class="keyword">true</span>&gt;&gt;)</span><br><span class="line">    condition.await();</span><br><span class="line">  &lt;&lt;use shared resources&gt;&gt;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br></pre></td></tr></table></figure></p>
<p>A condition variable is associated with a lock, and a thread must hold that lock before being able to wait on the condition.</p>
<p>Once it holds the lock, it checks to see if the condition is already true,</p>
<ul>
<li>if true, use shared resources and then unlock</li>
<li>otherwise, it calls await(), which automatically unlocks the lock and blocks on the condition variable. The unlock and blocks operation is atomic.</li>
<li>when another thread calls signal() or signalAll() to set condition to true, await() unblocks and automatically reacquires the lock.</li>
<li>await() is called within a loop, coz we need to go back and recheck whether the condition is true.</li>
</ul>
<p>Dining Philosopher with condition<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> eating;</span><br><span class="line">  <span class="keyword">private</span> Philosopher left;</span><br><span class="line">  <span class="keyword">private</span> Philosopher right;</span><br><span class="line">  <span class="keyword">private</span> ReentrantLock table;</span><br><span class="line">  <span class="keyword">private</span> Condition condition;</span><br><span class="line">  <span class="keyword">private</span> Random random;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(ReentrantLock table)</span> </span>&#123;</span><br><span class="line">    eating = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.table = table;</span><br><span class="line">    condition = table.newCondition();</span><br><span class="line">    random = <span class="keyword">new</span> Random();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(Philosopher left)</span> </span>&#123; <span class="keyword">this</span>.left = left; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(Philosopher right)</span> </span>&#123; <span class="keyword">this</span>.right = right; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        think();</span><br><span class="line">        eat();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">think</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    table.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      eating = <span class="keyword">false</span>;</span><br><span class="line">      left.condition.signal();</span><br><span class="line">      right.condition.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; table.unlock(); &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    table.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (left.eating || right.eating)</span><br><span class="line">        condition.await();</span><br><span class="line">      eating = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; table.unlock(); &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Still, a thread represents a philosopher, yet in this version, a philosopher no longer tries to hold two chopsticks.</p>
<p>Instead, the lock is acted on the table, which means the status of all of the 5 philosophers (or 5 chopsticks).</p>
<p>In think(), a philosopher first lock the current status of table, then he send signal the the philosophers sit beside him that he will unlock the table.</p>
<p>In eat(), a philosopher first lock the current status, then he waits for his neighbors to finish eating; if so, he will enter eat stat, and unlock the table.</p>
<p><strong>Atomic Variables</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counting</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger counter = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CountingThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10000</span>; ++x)</span><br><span class="line">          counter.incrementAndGet();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CountingThread t1 = <span class="keyword">new</span> CountingThread();</span><br><span class="line">    CountingThread t2 = <span class="keyword">new</span> CountingThread();</span><br><span class="line">    t1.start(); t2.start();</span><br><span class="line">    t1.join(); t2.join();</span><br><span class="line">    System.out.println(counter.get());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>incrementAndGet() &amp;&amp; getAndIncrement() are atomic functions for Atomic Variable counter. Using an atomic variable instead of locks has many benefits:</p>
<ol>
<li>Not possible to forget to acquire locks when necessary.</li>
<li>No locks are involves, so dead-lock free.</li>
<li>Atomic varaibles are the foundation of non-blocking algorithm, for example the classes in java.util.concurrent model.</li>
</ol>
<p><strong>Thread-Creation Redux</strong></p>
<p>A better way to create thread:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConnectionHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      ......</span><br><span class="line">      ConnectionHandler(Socket socket) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ......</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">4567</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      Socket socket = server.accept();</span><br><span class="line">      Thread handler = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ConnectionHandler(socket));</span><br><span class="line">      handler.start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Works fine, but suffers from a couple of issues:</p>
<ol>
<li>Although thread creation is cheap, it is not free, still pay the price for each connection.</li>
<li>It create as many threads as connections, and when connections come in faster than they could be handled, server will break – DDOS</li>
</ol>
<p>Better way to go?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">4567</span>);</span><br><span class="line"><span class="keyword">int</span> threadPoolSize = Runtime.getRuntime().availableProcessors() * <span class="number">2</span>;</span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(threadPoolSize);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  Socket socket = server.accept();</span><br><span class="line">  executor.execute(<span class="keyword">new</span> ConnectionHandler(socket));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Using a thread pool with twice as many threads as there are available processors.</p>
<p>If connections come in fast, they will be queued until a thread become free.</p>
<p><strong>Copy on Write</strong></p>
<p>Recall the <em>The peril of Alien Method</em> section, we use a temporary list to hold listeners; Better way to go??<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CopyOnWriteArrayList&lt;ProgressListener&gt; listeners;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Downloader</span><span class="params">(URL url, String outputFilename)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  listeners = <span class="keyword">new</span> CopyOnWriteArrayList&lt;ProgressListener&gt;();</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateProgress</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (ProgressListener listener: listeners)</span><br><span class="line">    listener.onProgress(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>It results in very clear and concise code, and more important, it don’t make a copy each time updateProgress() is called,<br>but only when listeners is modified (some listeners’ updateProgress() func may not change the listeners).</p>
<p><strong>Word Count - Sequential</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Iterable&lt;Page&gt; pages = <span class="keyword">new</span> Pages(<span class="number">100000</span>, <span class="string">"enwiki.xml"</span>);</span><br><span class="line">  <span class="keyword">for</span>(Page page: pages) &#123;</span><br><span class="line">    Iterable&lt;String&gt; words = <span class="keyword">new</span> Words(page.getText());</span><br><span class="line">    <span class="keyword">for</span> (String word: words)</span><br><span class="line">      countWord(word);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">  Integer currentCount = counts.get(word);</span><br><span class="line">  <span class="keyword">if</span> (currentCount == <span class="keyword">null</span>)</span><br><span class="line">    counts.put(word, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    counts.put(word, currentCount + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>105 seconds to finish.</p>
<p><strong>Word Count - Producer &amp; Consumer threads</strong></p>
<p>producer:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> BlockingQueue&lt;Page&gt; queue;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Parser</span><span class="params">(BlockingQueue&lt;Page&gt; queue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = queue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Iterable&lt;Page&gt; pages = <span class="keyword">new</span> Pages(<span class="number">100000</span>, <span class="string">"enwiki.xml"</span>);</span><br><span class="line">      <span class="keyword">for</span> (Page page: pages)</span><br><span class="line">        queue.put(page);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>consumer:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> BlockingQueue&lt;Page&gt; queue;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, Integer&gt; counts;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Counter</span><span class="params">(BlockingQueue&lt;Page&gt; queue, Map&lt;String, Integer&gt; counts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    <span class="keyword">this</span>.counts = counts;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        Page page = queue.take();</span><br><span class="line">        <span class="keyword">if</span> (page.isPoisonPill())</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        Iterable&lt;String&gt; words = <span class="keyword">new</span> Words(page.getText());</span><br><span class="line">        <span class="keyword">for</span> (String word: words)</span><br><span class="line">          countWord(word);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">countWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>main thread:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  ArrayBlockingQueue&lt;Page&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Page&gt;(<span class="number">100</span>);</span><br><span class="line">  HashMap&lt;String, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">  Thread counter = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Counter(queue, counts));</span><br><span class="line">  Thread parser = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Parser(queue));</span><br><span class="line">  counter.start();</span><br><span class="line">  parser.start();</span><br><span class="line">  parser.join();</span><br><span class="line">  queue.put(<span class="keyword">new</span> PoisonPill());</span><br><span class="line">  counter.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>95 seconds to finish, and we found that parsing wiki pages will only take 10 seconds to finish.</p>
<p>Since producer &amp; consumer start at the same time, so producer(parse pages) take 10 seconds and consumer(count words) takes 95 seconds.</p>
<p>Good, but not good enough.</p>
<p><strong>Word Count – multiple consumers using synchronized map</strong></p>
<p>Synchronized collections don’t provide atomic read-modify-write methods. so locks are necessary.</p>
<p>consumer:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Counter</span><span class="params">(BlockingQueue&lt;Page&gt; queue, Map&lt;String, Integer&gt; counts)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">countWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Integer currentCount = counts.get(word);</span><br><span class="line">      <span class="keyword">if</span> (currentCount == <span class="keyword">null</span>)</span><br><span class="line">        counts.put(word, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        counts.put(word, currentCount + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Notes that the lock is static, so the lock is shared among all consumers.</p>
<p>main thread:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_COUNTERS = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  ArrayBlockingQueue&lt;Page&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Page&gt;(<span class="number">100</span>);</span><br><span class="line">  HashMap&lt;String, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">  ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_COUNTERS; ++i)</span><br><span class="line">    executor.execute(<span class="keyword">new</span> Counter(queue, counts));</span><br><span class="line">  Thread parser = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Parser(queue));</span><br><span class="line">  parser.start();</span><br><span class="line">  parser.join();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_COUNTERS; ++i)</span><br><span class="line">    queue.put(<span class="keyword">new</span> PoisonPill());</span><br><span class="line">  executor.shutdown();</span><br><span class="line">  executor.awaitTermination(<span class="number">10L</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>212 seconds to finish using 2 consumers, even longer than the sequential version.</p>
<p>Why?? Excessive contention - too many threads are trying to access a single shared resource simultaneousely, so lock / unlock takes too many time.</p>
<p><strong>Word Count - Multi consumers using ConcurrentHashMap</strong></p>
<p>ConcurrentHashMap to rescue – which provide atomic functions.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">countWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    Integer currentCount = counts.get(word);</span><br><span class="line">    <span class="keyword">if</span> (currentCount == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (counts.putIfAbsent(word, <span class="number">1</span>) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (counts.replace(word, currentCount, currentCount + <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>It is faster cause it is lock free.</p>
<p>The workflow in countWord function is changed, the modification process of the varaible counts is held in a loop.</p>
<p>First it will get the current value of counts, then it will *update it based on the current value, for example:</p>
<p>When current is null, update it with putIfAbsent(). If putIfAbsent() is actually called AFTER some thread increases counts, it will fail.</p>
<p>When current is currentCount, update it with replace() parametrized with currentCount. If replace() is called AFTER current value is changed, it will fail.</p>
<p>In the case that the update function fails, the update process will loop again and get the updated current value of counts.</p>
<p>Even the putIfAbsent() or replace() could fail and re-run, this version is still much more faster because it is LOCK-FREE.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Consumers   Time(s)   Speedup</span><br><span class="line">1           120       0.87</span><br><span class="line">2           83        1.26</span><br><span class="line">3           65        1.61</span><br><span class="line">4           63        1.67    &lt;-- best one</span><br><span class="line">5           70        1.50</span><br><span class="line">6           79        1.33</span><br></pre></td></tr></table></figure>
<p><strong>Word Count - local counts and merge at last</strong></p>
<p>Instead of each consumers updating a shared set of counts concurrently, each should maintain its own local set, then merge these local sets in the end.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeCounts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e: localCounts.entrySet()) &#123;</span><br><span class="line">    String word = e.getKey();</span><br><span class="line">    Integer count = e.getValue();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      Integer currentCount = counts.get(word);</span><br><span class="line">      <span class="keyword">if</span> (currentCount == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (counts.putIfAbsent(word, count) == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (counts.replace(word, currentCount, currentCount + count)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mergeCounts is called by every consumer after it has already get to the end of the queue (page.isPoisonPill()).</p>
<p>So ConcurrentHashMap &amp;&amp; Atomic functions are still necessary.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Consumers   Time(s)   Speedup</span><br><span class="line">1           95        1.10</span><br><span class="line">2           57        1.83</span><br><span class="line">3           40        2.62</span><br><span class="line">4           39        2.69</span><br><span class="line">5           35        2.96</span><br><span class="line">6           33        3.14    &lt;-- best one</span><br><span class="line">7           41        2.55</span><br></pre></td></tr></table></figure>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/并发/" rel="tag">#并发</a>
          
            <a href="/tags/多线程/" rel="tag">#多线程</a>
          
            <a href="/tags/7日7并发模型/" rel="tag">#7日7并发模型</a>
          
            <a href="/tags/笔记/" rel="tag">#笔记</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/06/28/7concurrent-models-in-7weeks-part3/" rel="prev" title="7周7并发模型 P3 - Seperate Identity from State in Clojure Way">
                7周7并发模型 P3 - Seperate Identity from State in Clojure Way <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/06/28/7concurrent-models-in-7weeks-part1/"
           data-title="7周7并发模型 P1 - Thread and Lock" data-url="http://ijustloveses.github.io/2016/06/28/7concurrent-models-in-7weeks-part1/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="泡茶" />
          <p class="site-author-name" itemprop="name">泡茶</p>
          <p class="site-description motion-element" itemprop="description">专注并发和机器学习</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">34</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ijustloveses" target="_blank" title="Github" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <p class="post-toc-empty">此文章未包含目录</p>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">泡茶</span>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"paochashuo"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  






  
  
  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
